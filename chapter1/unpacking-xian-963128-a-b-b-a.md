## Python unpacking 陷阱

在Python 中, 交换两个变量的值是非常方便的, 只需要使用unpacking\(解包\)

```
a, b = b, a
# list 也同样可以
a[i], a[j] = a[j], a[i]
```

这两个都是可以正常交换的, 但是下面这个就不一样了

```
j = 0
m = [1, 3, 5] 
j, m[j] = m[j], 99
```

结果出乎意料:

```
print(j)    # 1
print(m)    # [1, 99, 5]
```

并非如我预期的m\[0\]被写为99，而是m\[1\]被写了。如果我们交换该语句两边对应的顺序：

```
m[j], j = 99, m[j]

print(j)    # 1
print(m)    # [99, 3, 5] # different result
```

省略原作者的分析, 看结论: 

> 在执行unpacking绑定时，j的值是**实时**存取的，**所以m\[j\]载入的是刚被改写的新的j值，**而且子表达式的绑定顺序是**从左至右**。
>
> 相比之下，等号**右侧的整个结构值则不是实时**的，在执行unpacking之前已入栈预存起来

也就是说上面式子实际执行时是这样的

```
j = 0
m = [1, 3, 5] 
j, m[j] = m[j], 99

# 先计算等式右侧的值
# j, m[j] = 1, 99
# 等式左侧载入实时读取的新值, 所以 j = 1 
# j, m[1] = 1, 99
# 然后遍历左侧进行绑定
```

> Python将右侧先整体求值并缓存结果，然后遍历左侧进行绑定

参考: [Python在unpacking上的一个小陷阱](https://zhuanlan.zhihu.com/p/25436739)

